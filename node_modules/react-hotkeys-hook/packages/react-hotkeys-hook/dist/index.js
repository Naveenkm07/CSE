import { createContext as I, useContext as q, useState as A, useCallback as w, useRef as S, useLayoutEffect as Q, useEffect as U } from "react";
import { jsx as R } from "react/jsx-runtime";
const F = ["shift", "alt", "meta", "mod", "ctrl", "control"], V = {
  esc: "escape",
  return: "enter",
  left: "arrowleft",
  right: "arrowright",
  up: "arrowup",
  down: "arrowdown",
  ShiftLeft: "shift",
  ShiftRight: "shift",
  AltLeft: "alt",
  AltRight: "alt",
  MetaLeft: "meta",
  MetaRight: "meta",
  OSLeft: "meta",
  OSRight: "meta",
  ControlLeft: "ctrl",
  ControlRight: "ctrl"
};
function g(t) {
  return (V[t.trim()] || t.trim()).toLowerCase().replace(/key|digit|numpad/, "");
}
function X(t) {
  return F.includes(t);
}
function P(t, r = ",") {
  return t.toLowerCase().split(r);
}
function b(t, r = "+", n = !1, a) {
  const c = t.toLocaleLowerCase().split(r).map((i) => g(i)), l = {
    alt: c.includes("alt"),
    ctrl: c.includes("ctrl") || c.includes("control"),
    shift: c.includes("shift"),
    meta: c.includes("meta"),
    mod: c.includes("mod"),
    useKey: n
  }, o = c.filter((i) => !F.includes(i));
  return {
    ...l,
    keys: o,
    description: a
  };
}
typeof document < "u" && (document.addEventListener("keydown", (t) => {
  t.code !== void 0 && T([g(t.code)]);
}), document.addEventListener("keyup", (t) => {
  t.code !== void 0 && W([g(t.code)]);
})), typeof window < "u" && window.addEventListener("blur", () => {
  v.clear();
});
const v = /* @__PURE__ */ new Set();
function B(t) {
  return Array.isArray(t);
}
function Y(t, r = ",") {
  return (B(t) ? t : t.split(r)).every((a) => v.has(a.trim().toLowerCase()));
}
function T(t) {
  const r = Array.isArray(t) ? t : [t];
  v.has("meta") && v.forEach((n) => !X(n) && v.delete(n.toLowerCase())), r.forEach((n) => v.add(n.toLowerCase()));
}
function W(t) {
  const r = Array.isArray(t) ? t : [t];
  t === "meta" ? v.clear() : r.forEach((n) => v.delete(n.toLowerCase()));
}
function Z(t, r, n) {
  (typeof n == "function" && n(t, r) || n === !0) && t.preventDefault();
}
function $(t, r, n) {
  return typeof n == "function" ? n(t, r) : n === !0 || n === void 0;
}
function _(t) {
  return z(t, ["input", "textarea", "select"]);
}
function z(t, r = !1) {
  const { target: n, composed: a } = t;
  let c;
  return m(n) && a ? c = t.composedPath()[0] && t.composedPath()[0].tagName : c = n && n.tagName, B(r) ? !!(c && r && r.some((l) => l.toLowerCase() === c.toLowerCase())) : !!(c && r && r);
}
function m(t) {
  return !!t.tagName && !t.tagName.startsWith("-") && t.tagName.includes("-");
}
function O(t, r) {
  return t.length === 0 && r ? (console.warn(
    'A hotkey has the "scopes" option set, however no active scopes were found. If you want to use the global scopes feature, you need to wrap your app in a <HotkeysProvider>'
  ), !0) : r ? t.some((n) => r.includes(n)) || t.includes("*") : !0;
}
const ee = (t, r, n = !1) => {
  const { alt: a, meta: c, mod: l, shift: o, ctrl: i, keys: f, useKey: y } = r, { code: k, key: e, ctrlKey: s, metaKey: d, shiftKey: C, altKey: H } = t, h = g(k);
  if (y && (f == null ? void 0 : f.length) === 1 && f.includes(e))
    return !0;
  if (!(f != null && f.includes(h)) && !["ctrl", "control", "unknown", "meta", "alt", "shift", "os"].includes(h))
    return !1;
  if (!n) {
    if (a !== H && h !== "alt" || o !== C && h !== "shift")
      return !1;
    if (l) {
      if (!d && !s)
        return !1;
    } else if (c !== d && h !== "meta" && h !== "os" || i !== s && h !== "ctrl" && h !== "control")
      return !1;
  }
  return f && f.length === 1 && f.includes(h) ? !0 : f ? Y(f) : !f;
}, G = I(void 0), te = () => q(G);
function re({ addHotkey: t, removeHotkey: r, children: n }) {
  return /* @__PURE__ */ R(G.Provider, { value: { addHotkey: t, removeHotkey: r }, children: n });
}
function N(t, r) {
  return t && r && typeof t == "object" && typeof r == "object" ? Object.keys(t).length === Object.keys(r).length && // @ts-expect-error TS7053
  Object.keys(t).reduce((n, a) => n && N(t[a], r[a]), !0) : t === r;
}
const J = I({
  hotkeys: [],
  activeScopes: [],
  // This array has to be empty instead of containing '*' as default, to check if the provider is set or not
  toggleScope: () => {
  },
  enableScope: () => {
  },
  disableScope: () => {
  }
}), ne = () => q(J), fe = ({ initiallyActiveScopes: t = ["*"], children: r }) => {
  const [n, a] = A(t), [c, l] = A([]), o = w((e) => {
    a((s) => s.includes("*") ? [e] : Array.from(/* @__PURE__ */ new Set([...s, e])));
  }, []), i = w((e) => {
    a((s) => s.filter((d) => d !== e));
  }, []), f = w((e) => {
    a((s) => s.includes(e) ? s.filter((d) => d !== e) : s.includes("*") ? [e] : Array.from(/* @__PURE__ */ new Set([...s, e])));
  }, []), y = w((e) => {
    l((s) => [...s, e]);
  }, []), k = w((e) => {
    l((s) => s.filter((d) => !N(d, e)));
  }, []);
  return /* @__PURE__ */ R(
    J.Provider,
    {
      value: { activeScopes: n, hotkeys: c, enableScope: o, disableScope: i, toggleScope: f },
      children: /* @__PURE__ */ R(re, { addHotkey: y, removeHotkey: k, children: r })
    }
  );
};
function oe(t) {
  const r = S(void 0);
  return N(r.current, t) || (r.current = t), r.current;
}
const D = (t) => {
  t.stopPropagation(), t.preventDefault(), t.stopImmediatePropagation();
}, ce = typeof window < "u" ? Q : U;
function se(t, r, n, a) {
  const c = S(null), l = S(!1), o = n instanceof Array ? a instanceof Array ? void 0 : a : n, i = B(t) ? t.join(o == null ? void 0 : o.delimiter) : t, f = n instanceof Array ? n : a instanceof Array ? a : void 0, y = w(r, f ?? []), k = S(y);
  f ? k.current = y : k.current = r;
  const e = oe(o), { activeScopes: s } = ne(), d = te();
  return ce(() => {
    if ((e == null ? void 0 : e.enabled) === !1 || !O(s, e == null ? void 0 : e.scopes))
      return;
    const C = (u, p = !1) => {
      var j;
      if (!(_(u) && !z(u, e == null ? void 0 : e.enableOnFormTags))) {
        if (c.current !== null) {
          const E = c.current.getRootNode();
          if ((E instanceof Document || E instanceof ShadowRoot) && E.activeElement !== c.current && !c.current.contains(E.activeElement)) {
            D(u);
            return;
          }
        }
        (j = u.target) != null && j.isContentEditable && !(e != null && e.enableOnContentEditable) || P(i, e == null ? void 0 : e.delimiter).forEach((E) => {
          var M, x;
          const L = b(E, e == null ? void 0 : e.splitKey, e == null ? void 0 : e.useKey, e == null ? void 0 : e.description);
          if (ee(u, L, e == null ? void 0 : e.ignoreModifiers) || (M = L.keys) != null && M.includes("*")) {
            if ((x = e == null ? void 0 : e.ignoreEventWhen) != null && x.call(e, u) || p && l.current)
              return;
            if (Z(u, L, e == null ? void 0 : e.preventDefault), !$(u, L, e == null ? void 0 : e.enabled)) {
              D(u);
              return;
            }
            k.current(u, L), p || (l.current = !0);
          }
        });
      }
    }, H = (u) => {
      u.code !== void 0 && (T(g(u.code)), ((e == null ? void 0 : e.keydown) === void 0 && (e == null ? void 0 : e.keyup) !== !0 || e != null && e.keydown) && C(u));
    }, h = (u) => {
      u.code !== void 0 && (W(g(u.code)), l.current = !1, e != null && e.keyup && C(u, !0));
    }, K = c.current || (o == null ? void 0 : o.document) || document;
    return K.addEventListener("keyup", h, o == null ? void 0 : o.eventListenerOptions), K.addEventListener("keydown", H, o == null ? void 0 : o.eventListenerOptions), d && P(i, e == null ? void 0 : e.delimiter).forEach(
      (u) => d.addHotkey(
        b(u, e == null ? void 0 : e.splitKey, e == null ? void 0 : e.useKey, e == null ? void 0 : e.description)
      )
    ), () => {
      K.removeEventListener("keyup", h, o == null ? void 0 : o.eventListenerOptions), K.removeEventListener("keydown", H, o == null ? void 0 : o.eventListenerOptions), d && P(i, e == null ? void 0 : e.delimiter).forEach(
        (u) => d.removeHotkey(
          b(u, e == null ? void 0 : e.splitKey, e == null ? void 0 : e.useKey, e == null ? void 0 : e.description)
        )
      );
    };
  }, [i, e, s]), c;
}
function le(t = !1) {
  const [r, n] = A(/* @__PURE__ */ new Set()), [a, c] = A(!1), l = w((y) => {
    y.code !== void 0 && (y.preventDefault(), y.stopPropagation(), n((k) => {
      const e = new Set(k);
      return e.add(g(t ? y.key : y.code)), e;
    }));
  }, [t]), o = w(() => {
    typeof document < "u" && (document.removeEventListener("keydown", l), c(!1));
  }, [l]), i = w(() => {
    n(/* @__PURE__ */ new Set()), typeof document < "u" && (o(), document.addEventListener("keydown", l), c(!0));
  }, [l, o]), f = w(() => {
    n(/* @__PURE__ */ new Set());
  }, []);
  return [r, { start: i, stop: o, resetKeys: f, isRecording: a }];
}
export {
  fe as HotkeysProvider,
  Y as isHotkeyPressed,
  se as useHotkeys,
  ne as useHotkeysContext,
  le as useRecordHotkeys
};
